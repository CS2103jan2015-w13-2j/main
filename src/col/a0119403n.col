//@author: a0119403n



	/**
	 * origin: E:\cs2103final\src\IntegrationTest.java
	 */

public class IntegrationTest {

	private static final String TEST_FILENAME = "TestFileName.txt";
	private static final String CLEAR_COMMAND = "clear";
	private static final String DISPLAY_COMMAND = "display";
	private static final String ADD_COMMAND_1 = "add jumped over the moon";
	private static final String ADD_COMMAND_2 = "add little brown fox";
	private static final String DELETE_COMMAND_1 = "delete 1";
	private static final String SORT_COMMAND = "sort title";
	private static final String SEARCH_COMMAND_1 = "search word1";
	private static final String SEARCH_COMMAND_2 = "search word2";
	private static final String SEARCH_COMMAND_NOT_EXIST = "search word22222";
	
	private static final String EXCEPTED_ANSWER_CLEAR = "";
	private static final String EXCEPTED_ANSWER_ADD_1 = "1. little brown fox\n";
	private static final String EXCEPTED_ANSWER_ADD_2 = "1. little brown fox\n2. jumped over the moon\n";
	private static final String EXCEPTED_ANSWER_DELETE_1 = "1. jumped over the moon\n";
	private static final String EXCEPTED_ANSWER_DISPLAY = "1. jumped over the moon\n";
	
	//Strings used for sort test
	private static final String A_STRING = "a this is a string starts with a";
	private static final String B_STRING = "b this is a string starts with b";
	private static final String C_STRING = "c this is a string starts with c";
	private static final String D_STRING = "d this is a string starts with d";
	private static final String E_STRING = "e this is a string starts with e";
	private static final String F_STRING = "f this is a string starts with f";
	private static final String G_STRING = "g this is a string starts with g";
	private static final String EXCEPTED_ANSWER_SORT = "1. a this is a string starts with a\n2. b this is a string starts with b\n3. c this is a string starts with c\n4. d this is a string starts with d\n5. e this is a string starts with e\n6. f this is a string starts with f\n7. g this is a string starts with g\n";
	//Strings used for search test
	private static final String SEARCH_STRING_1 = "word1 word2 word3 word4 word5 word6 word7 word8";
	private static final String SEARCH_STRING_2 = "word1 word3 word5 word7";
	private static final String SEARCH_STRING_3 = "word2 word4 word6 word8";
	private static final String SEARCH_STRING_4 = "word1 word2 word3 word4";
	private static final String SEARCH_STRING_5 = "word5 word6 word7 word8";
	private static final String SEARCH_STRING_6 = "word1 word6 word7 word8";
	private static final String SEARCH_STRING_7 = "word2 word3 word4 word5";
	private static final String SEARCH_STRING_8 = "word4 word6 word7 word8";
	private static final String SEARCH_STRING_9 = "word1 word3 word5 word6";
	private static final String SEARCH_STRING_10 = "word1 word3 word7 word8";
	private static final String NOT_EXIST = "No results found\n";
	
	
	
	@Test
	public void testBasicFunctions() throws NullPointerException, IOException {
		
		//Set up test case
		String[] args = new String[1];
		args[0] = TEST_FILENAME;
		TaskManager taskList = new TaskManager(args[0]);
		
		//test clear
		testOneCommand("simple clear",EXCEPTED_ANSWER_CLEAR, CLEAR_COMMAND,taskList);
		
		//test add
		testOneCommand("simple add1",EXCEPTED_ANSWER_ADD_1, ADD_COMMAND_2,taskList);
		
		//test add
		testOneCommand("simple add2",EXCEPTED_ANSWER_ADD_2, ADD_COMMAND_1,taskList);
		
		//test delete
		testOneCommand("simple delete 1",EXCEPTED_ANSWER_DELETE_1, DELETE_COMMAND_1,taskList);
		
		//test delete negative 
		testOneCommand("simple delete 2",EXCEPTED_ANSWER_DELETE_1, "delete -10",taskList);
		
				
		//test delete large index 
		testOneCommand("simple delete 4",EXCEPTED_ANSWER_DELETE_1, "delete 100",taskList);
		
		//test display
		testOneCommand("simple display",EXCEPTED_ANSWER_DISPLAY, DISPLAY_COMMAND,taskList);
		TaskManager taskList2 = new TaskManager(args[0]);
		assertEquals("See whether file saved successfully", taskList.isEqual(taskList2), true);
	}
	@Test
	public void testSearch() throws NullPointerException, IOException {
		
		//set up testcase
		String[] args = new String[1];
		args[0] = TEST_FILENAME;
		TaskManager taskList = new TaskManager(args[0]);
		
		//testcase 1
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+SEARCH_STRING_1);
		taskList.executeCommand("add "+SEARCH_STRING_2);
		taskList.executeCommand("add "+SEARCH_STRING_3);
		taskList.executeCommand("add "+SEARCH_STRING_4);
		taskList.executeCommand("add "+SEARCH_STRING_5);
		taskList.executeCommand("add "+SEARCH_STRING_6);
		taskList.executeCommand("add "+SEARCH_STRING_7);
		taskList.executeCommand("add "+SEARCH_STRING_8);
		taskList.executeCommand("add "+SEARCH_STRING_9);
		taskList.executeCommand("add "+SEARCH_STRING_10);
		String exceptedSearchResult = String.format("1. %s\n2. %s\n3. %s\n4. %s\n5. %s\n6. %s\n", SEARCH_STRING_1,SEARCH_STRING_2,SEARCH_STRING_4,SEARCH_STRING_6,SEARCH_STRING_9,SEARCH_STRING_10);
		testOneCommand("simple search",exceptedSearchResult, SEARCH_COMMAND_1,taskList);
	
		//testcase 2
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+SEARCH_STRING_1);
		taskList.executeCommand("add "+SEARCH_STRING_2);
		taskList.executeCommand("add "+SEARCH_STRING_3);
		taskList.executeCommand("add "+SEARCH_STRING_4);
		taskList.executeCommand("add "+SEARCH_STRING_5);
		taskList.executeCommand("add "+SEARCH_STRING_6);
		taskList.executeCommand("add "+SEARCH_STRING_7);
		taskList.executeCommand("add "+SEARCH_STRING_8);
		taskList.executeCommand("add "+SEARCH_STRING_9);
		taskList.executeCommand("add "+SEARCH_STRING_10);
		exceptedSearchResult = String.format("1. %s\n2. %s\n3. %s\n4. %s\n", SEARCH_STRING_1,SEARCH_STRING_3,SEARCH_STRING_4,SEARCH_STRING_7);
		testOneCommand("simple search",exceptedSearchResult, SEARCH_COMMAND_2,taskList);
	
		//testcase 3
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+SEARCH_STRING_1);
		taskList.executeCommand("add "+SEARCH_STRING_2);
		taskList.executeCommand("add "+SEARCH_STRING_3);
		taskList.executeCommand("add "+SEARCH_STRING_4);
		taskList.executeCommand("add "+SEARCH_STRING_5);
		taskList.executeCommand("add "+SEARCH_STRING_6);
		taskList.executeCommand("add "+SEARCH_STRING_7);
		taskList.executeCommand("add "+SEARCH_STRING_8);
		taskList.executeCommand("add "+SEARCH_STRING_9);
		taskList.executeCommand("add "+SEARCH_STRING_10);
		testOneCommand("simple search",NOT_EXIST, SEARCH_COMMAND_NOT_EXIST,taskList);
		TaskManager taskList2 = new TaskManager(args[0]);
		assertEquals("See whether file saved successfully", taskList.isEqual(taskList2), true);
	}
	
	@Test
	public void testSort() throws NullPointerException, IOException{
		//set up testcase
		String[] args = new String[1];
		args[0] = TEST_FILENAME;
		TaskManager taskList = new TaskManager(args[0]);
		
		//testcase 1
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+G_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+A_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		ArrayList<String> exceptedList = new ArrayList<String>();
		exceptedList.add(A_STRING);
		exceptedList.add(B_STRING);
		exceptedList.add(C_STRING);
		exceptedList.add(D_STRING);
		exceptedList.add(E_STRING);
		exceptedList.add(F_STRING);
		exceptedList.add(G_STRING);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
	
		//testcase 2
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+A_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+G_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
		TaskManager taskList2 = new TaskManager(args[0]);
		assertEquals("See whether file saved successfully", taskList.isEqual(taskList2), true);


	}
	@Test
	public void testFeedback() throws NullPointerException, IOException{


	}
	
	private void testOneCommand(String description, String expected, String command, TaskManager taskList) throws NullPointerException, IOException {
		taskList.executeCommand(command);
		System.out.println("Debug");
		System.out.println(expected);
		System.out.println(taskList.getAllTitles());
		assertEquals(description, expected, taskList.getAllTitles()); 
		
	}

}
	// End of segment: E:\cs2103final\src\IntegrationTest.java





	/**
	 * origin: E:\cs2103final\src\taskList\Task.java
	 */

public class Task implements Comparable<Task>{
	private String content;
	private String venue;
	private Date date;
	private Date deadline;
	private String dateString;
	private String deadlineString;
	private boolean hasFinished = false;
	static Parser taskParser = new Parser();
	static SimpleDateFormat dateFormat; 
	public Task(String content){
		this.content = content;
	}
	
	public Task(String content, String date) throws NullPointerException, IOException{
		this.content = content;
		
		DateParser dateParser = new DateParser();
		try{
			this.date = dateParser.getDate(date);	
		}catch (Exception exception){
			new Exception("NullPointerException");
		}
		
		if(date != null)
			dateString = date.toString();
		//new SimpleDateFormat("YYYY-MM-dd HH:mm").format(date);
	}
	
	public Task(String content, String date, String deadline, String venue){
		this.content = content;
		
		DateParser dateParser = new DateParser();
		try {
			this.date = dateParser.getDate(date);
		} catch (Exception e) {
			this.date = null;
		}
		try {
			this.deadline = dateParser.getDate(deadline);
		} catch (Exception e) {
			this.deadline = null;
		}
		
		
		if(date != null)
			dateString = date.toString();
		
		if(deadline != null)
			deadlineString = deadline.toString();
		
		this.venue = venue;
	}
	public Task(String content, String date, String deadline, String venue , boolean hasFinished){
		this.content = content;
		
		DateParser dateParser = new DateParser();
		try {
			this.date = dateParser.getDate(date);
		} catch (Exception e) {
			this.date = null;
		}
		try {
			this.deadline = dateParser.getDate(deadline);
		} catch (Exception e) {
			this.deadline = null;
		}
		
		
		if(date != null)
			dateString = date.toString();
		
		if(deadline != null)
			deadlineString = deadline.toString();
		this.hasFinished = hasFinished;
		this.venue = venue;
	}
	public Task(String content, Date date, Date deadline, String venue){
		this.content = content;
		this.date = date;
		this.deadline = deadline;
		
		if(date != null)
			dateString = new SimpleDateFormat(DateParser.FORMAT_DEFAULT).format(this.date);
		
		if(deadline != null)
			deadlineString = new SimpleDateFormat(DateParser.FORMAT_DEFAULT).format(this.deadline);
		
		this.venue = venue;
	}
	
	public Task(String content, Date date, Date deadline, String venue, boolean hasFinished){
		this.content = content;
		this.date = date;
		this.deadline = deadline;
		
		if(date != null)
			dateString = new SimpleDateFormat(DateParser.FORMAT_DEFAULT).format(this.date);
		
		if(deadline != null)
			deadlineString = new SimpleDateFormat(DateParser.FORMAT_DEFAULT).format(this.deadline);
		this.hasFinished = hasFinished;
		this.venue = venue;
	}
	
	public String getContent(){
		return content;
	}
	
	public void setContent(String newContent){
		if (newContent == null) return;
		this.content = newContent;
	}
	
	public Date getDate(){
		return this.date;
	}
	
	public void setDate(Date newDate){
		if (newDate == null) return;
		this.date = newDate;
	}
	
	public String getVenue(){
		return this.venue;
	}
	
	public void setVenue(String newVenue){
		if (newVenue == null){
			return;
		}
		this.venue = newVenue;
	}
	
	public Date getDeadline(){
		return this.deadline;
	}
	
	public void setDeadLine(Date newDeadLine){
		if (newDeadLine == null){
			return;
		}
		this.deadline = newDeadLine;
	}
	
	public String getDeadlineString(){
		return deadlineString;
	}
	public String getDateString(){
		return dateString;
	}

	@Override
	public int compareTo(Task o) {
		return -(o.getContent().compareTo(this.getContent()));
	}
	
	public boolean hasFinished(){
		return this.hasFinished;
	}
	
	public void finish(){
		this.hasFinished = true;
	}
	
	public boolean sameString(String string1, String string2){
		if (string1 == null){
			if (string2 == null) return true;
			return false;
		}else{
			return string1.equals(string2);
		}
	}
	
	public boolean sameDate(Date date1, Date date2){
		if (date1 == null){
			if (date2 == null) return true;
			return false;
		}else{
			return date1.equals(date2);
		}
	}
	
	
	public boolean isEqual(Task task2){

		return (sameString(this.content,task2.content) && sameString(this.venue,(task2.venue)) && sameDate(this.date,(task2.date)));
	}
	
	public boolean containKeyWord(String keyWord){
		boolean answer = false;
		if (this.content != null)
			answer |= this.content.contains(keyWord);
		if (this.venue != null)
			answer |= this.venue.contains(keyWord);
		if (this.date != null)
			System.out.println("debug time "+ new SimpleDateFormat(DateParser.FORMAT_DEFAULT).format(this.date));
		if (this.date != null)
			answer |= new SimpleDateFormat(DateParser.FORMAT_DEFAULT).format(this.date).contains(keyWord);
		return answer;
	}
	
	public boolean isTodayTask() throws NullPointerException, IOException{
		Date today = taskParser.getDate("add -d today");
		dateFormat = new SimpleDateFormat(DateParser.FORMAT_DEFAULT);
		if (date == null) {
			if (deadline == null)return false;else return (dateFormat.format(date).equals((dateFormat).format(today)));
		}else
		return (dateFormat.format(date).equals((dateFormat).format(today)));
	}
	
	public boolean isOutOfDate() throws NullPointerException, IOException{
		Date today = taskParser.getDate("add -d today");
		System.out.println("today is " +today);
		if (deadline == null){
			if (date == null) return false;else {
				System.out.println("debug ");
				System.out.println(today.after(date));
				
				return (today.after(date));
			}
		}else
		return (today.after(deadline));
	}
	
	public Task getCopy(){
		return new Task(this.content,this.date,this.deadline,this.venue,this.hasFinished);
	}
	
}

	// End of segment: E:\cs2103final\src\taskList\Task.java





	/**
	 * origin: E:\cs2103final\src\taskList\TaskListTest.java
	 */

public class TaskListTest {
	//String used to test CE1
	private static final String TEST_FILENAME = "CaoShengze.txt";
	private static final String CLEAR_COMMAND = "clear";
	private static final String DISPLAY_COMMAND = "display";
	private static final String ADD_COMMAND_1 = "add jumped over the moon";
	private static final String ADD_COMMAND_2 = "add little brown fox";
	private static final String DELETE_COMMAND_1 = "delete 1";
	private static final String SORT_COMMAND = "sort title";
	private static final String SEARCH_COMMAND_1 = "search word1";
	private static final String SEARCH_COMMAND_2 = "search word2";
	private static final String SEARCH_COMMAND_NOT_EXIST = "search word22222";
	
	//Excepted Answer to CE1
	private static final String EXCEPTED_ANSWER_CLEAR = "";
	private static final String EXCEPTED_ANSWER_ADD_1 = "1. little brown fox\n";
	private static final String EXCEPTED_ANSWER_ADD_2 = "1. little brown fox\n2. jumped over the moon\n";
	private static final String EXCEPTED_ANSWER_DELETE_1 = "1. jumped over the moon\n";
	private static final String EXCEPTED_ANSWER_DISPLAY = "1. jumped over the moon\n";
	
	//Strings used for sort test
	private static final String A_STRING = "a this is a string starts with a";
	private static final String B_STRING = "b this is a string starts with b";
	private static final String C_STRING = "c this is a string starts with c";
	private static final String D_STRING = "d this is a string starts with d";
	private static final String E_STRING = "e this is a string starts with e";
	private static final String F_STRING = "f this is a string starts with f";
	private static final String G_STRING = "g this is a string starts with g";
	private static final String EXCEPTED_ANSWER_SORT = "1. a this is a string starts with a\n2. b this is a string starts with b\n3. c this is a string starts with c\n4. d this is a string starts with d\n5. e this is a string starts with e\n6. f this is a string starts with f\n7. g this is a string starts with g\n";
	//Strings used for search test
	private static final String SEARCH_STRING_1 = "word1 word2 word3 word4 word5 word6 word7 word8";
	private static final String SEARCH_STRING_2 = "word1 word3 word5 word7";
	private static final String SEARCH_STRING_3 = "word2 word4 word6 word8";
	private static final String SEARCH_STRING_4 = "word1 word2 word3 word4";
	private static final String SEARCH_STRING_5 = "word5 word6 word7 word8";
	private static final String SEARCH_STRING_6 = "word1 word6 word7 word8";
	private static final String SEARCH_STRING_7 = "word2 word3 word4 word5";
	private static final String SEARCH_STRING_8 = "word4 word6 word7 word8";
	private static final String SEARCH_STRING_9 = "word1 word3 word5 word6";
	private static final String SEARCH_STRING_10 = "word1 word3 word7 word8";
	private static final String NOT_EXIST = "No results found\n";
	
	
	
	@Test
	public void testBasicFunctions() throws NullPointerException, IOException {
		
		//Set up test case
		String[] args = new String[1];
		args[0] = TEST_FILENAME;
		TaskManager taskList = new TaskManager(args[0]);
		
		//test clear
		testOneCommand("simple clear",EXCEPTED_ANSWER_CLEAR, CLEAR_COMMAND,taskList);
		
		//test add
		testOneCommand("simple add1",EXCEPTED_ANSWER_ADD_1, ADD_COMMAND_2,taskList);
		
		//test add
		testOneCommand("simple add2",EXCEPTED_ANSWER_ADD_2, ADD_COMMAND_1,taskList);
		
		//test delete
		testOneCommand("simple delete 1",EXCEPTED_ANSWER_DELETE_1, DELETE_COMMAND_1,taskList);
		
		//test delete negative 
		testOneCommand("simple delete 2",EXCEPTED_ANSWER_DELETE_1, "delete -10",taskList);
		
				
		//test delete large index 
		testOneCommand("simple delete 4",EXCEPTED_ANSWER_DELETE_1, "delete 100",taskList);
		
		//test display
		testOneCommand("simple display",EXCEPTED_ANSWER_DISPLAY, DISPLAY_COMMAND,taskList);
		
	}
	@Test
	public void testSearch() throws NullPointerException, IOException {
		
		//set up testcase
		String[] args = new String[1];
		args[0] = TEST_FILENAME;
		TaskManager taskList = new TaskManager(args[0]);
		
		//testcase 1
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+SEARCH_STRING_1);
		taskList.executeCommand("add "+SEARCH_STRING_2);
		taskList.executeCommand("add "+SEARCH_STRING_3);
		taskList.executeCommand("add "+SEARCH_STRING_4);
		taskList.executeCommand("add "+SEARCH_STRING_5);
		taskList.executeCommand("add "+SEARCH_STRING_6);
		taskList.executeCommand("add "+SEARCH_STRING_7);
		taskList.executeCommand("add "+SEARCH_STRING_8);
		taskList.executeCommand("add "+SEARCH_STRING_9);
		taskList.executeCommand("add "+SEARCH_STRING_10);
		String exceptedSearchResult = String.format("1. %s\n2. %s\n3. %s\n4. %s\n5. %s\n6. %s\n", SEARCH_STRING_1,SEARCH_STRING_2,SEARCH_STRING_4,SEARCH_STRING_6,SEARCH_STRING_9,SEARCH_STRING_10);
		testOneCommand("simple search",exceptedSearchResult, SEARCH_COMMAND_1,taskList);
	
		//testcase 2
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+SEARCH_STRING_1);
		taskList.executeCommand("add "+SEARCH_STRING_2);
		taskList.executeCommand("add "+SEARCH_STRING_3);
		taskList.executeCommand("add "+SEARCH_STRING_4);
		taskList.executeCommand("add "+SEARCH_STRING_5);
		taskList.executeCommand("add "+SEARCH_STRING_6);
		taskList.executeCommand("add "+SEARCH_STRING_7);
		taskList.executeCommand("add "+SEARCH_STRING_8);
		taskList.executeCommand("add "+SEARCH_STRING_9);
		taskList.executeCommand("add "+SEARCH_STRING_10);
		exceptedSearchResult = String.format("1. %s\n2. %s\n3. %s\n4. %s\n", SEARCH_STRING_1,SEARCH_STRING_3,SEARCH_STRING_4,SEARCH_STRING_7);
		testOneCommand("simple search",exceptedSearchResult, SEARCH_COMMAND_2,taskList);
	
		//testcase 3
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+SEARCH_STRING_1);
		taskList.executeCommand("add "+SEARCH_STRING_2);
		taskList.executeCommand("add "+SEARCH_STRING_3);
		taskList.executeCommand("add "+SEARCH_STRING_4);
		taskList.executeCommand("add "+SEARCH_STRING_5);
		taskList.executeCommand("add "+SEARCH_STRING_6);
		taskList.executeCommand("add "+SEARCH_STRING_7);
		taskList.executeCommand("add "+SEARCH_STRING_8);
		taskList.executeCommand("add "+SEARCH_STRING_9);
		taskList.executeCommand("add "+SEARCH_STRING_10);
		testOneCommand("simple search",NOT_EXIST, SEARCH_COMMAND_NOT_EXIST,taskList);
	}
	
	@Test
	public void testSort() throws NullPointerException, IOException{
		//set up testcase
		String[] args = new String[1];
		args[0] = TEST_FILENAME;
		TaskManager taskList = new TaskManager(args[0]);
		
		//testcase 1
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+G_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+A_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		ArrayList<String> exceptedList = new ArrayList<String>();
		exceptedList.add(A_STRING);
		exceptedList.add(B_STRING);
		exceptedList.add(C_STRING);
		exceptedList.add(D_STRING);
		exceptedList.add(E_STRING);
		exceptedList.add(F_STRING);
		exceptedList.add(G_STRING);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
	
		//testcase 2
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+A_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+G_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
	

	}
	
	@Test
	public void testUndo() throws NullPointerException, IOException{
		//set up testcase
		String[] args = new String[1];
		args[0] = TEST_FILENAME;
		TaskManager taskList = new TaskManager(args[0]);
		
		//testcase 1
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+G_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+A_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		ArrayList<String> exceptedList = new ArrayList<String>();
		exceptedList.add(A_STRING);
		exceptedList.add(B_STRING);
		exceptedList.add(C_STRING);
		exceptedList.add(D_STRING);
		exceptedList.add(E_STRING);
		exceptedList.add(F_STRING);
		exceptedList.add(G_STRING);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
		taskList.executeCommand(CLEAR_COMMAND);
		taskList.undo();
		assertEquals("undo test", exceptedList, taskList.getTaskList());
		
		//testcase 2
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+A_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+G_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
		taskList.executeCommand(CLEAR_COMMAND);
		taskList.undo();
		assertEquals("undo test", exceptedList, taskList.getTaskList());

	}
	
	@Test
	public void testRedo() throws NullPointerException, IOException{
		//set up testcase
		String[] args = new String[1];
		args[0] = TEST_FILENAME;
		TaskManager taskList = new TaskManager(args[0]);
		
		//testcase 1
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+G_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+A_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		ArrayList<String> exceptedList = new ArrayList<String>();
		exceptedList.add(A_STRING);
		exceptedList.add(B_STRING);
		exceptedList.add(C_STRING);
		exceptedList.add(D_STRING);
		exceptedList.add(E_STRING);
		exceptedList.add(F_STRING);
		exceptedList.add(G_STRING);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
		taskList.undo();
		taskList.redo();
		assertEquals("undo test", exceptedList, taskList.getTaskList());
		
		//testcase 2
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+A_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+G_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
		taskList.undo();
		taskList.redo();
		assertEquals("undo test", exceptedList, taskList.getTaskList());

	}
	
	@Test
	public void testImport() throws NullPointerException, IOException{
		//set up testcase
		String[] args = new String[1];
		args[0] = TEST_FILENAME;
		TaskManager taskList = new TaskManager(args[0]);
		
		//testcase 1
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+G_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+A_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		ArrayList<String> exceptedList = new ArrayList<String>();
		exceptedList.add(A_STRING);
		exceptedList.add(B_STRING);
		exceptedList.add(C_STRING);
		exceptedList.add(D_STRING);
		exceptedList.add(E_STRING);
		exceptedList.add(F_STRING);
		exceptedList.add(G_STRING);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
		taskList.undo();
		taskList.redo();
		assertEquals("undo test", exceptedList, taskList.getTaskList());
		
		//testcase 2
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+A_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+G_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
		taskList.undo();
		taskList.redo();
		assertEquals("undo test", exceptedList, taskList.getTaskList());
		
		TaskManager taskList2 = new TaskManager();
		taskList2.executeCommand("import "+args[0]);
		assertEquals("undo test", true, taskList.getAllTitles().equals(taskList2.getAllTitles()));
		
	}
	
	@Test
	public void testExport() throws NullPointerException, IOException{
		//set up testcase
		String[] args = new String[1];
		args[0] = TEST_FILENAME;
		TaskManager taskList = new TaskManager(args[0]);
		
		//testcase 1
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+G_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+A_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		ArrayList<String> exceptedList = new ArrayList<String>();
		exceptedList.add(A_STRING);
		exceptedList.add(B_STRING);
		exceptedList.add(C_STRING);
		exceptedList.add(D_STRING);
		exceptedList.add(E_STRING);
		exceptedList.add(F_STRING);
		exceptedList.add(G_STRING);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
		taskList.undo();
		taskList.redo();
		assertEquals("undo test", exceptedList, taskList.getTaskList());
		
		//testcase 2
		taskList.executeCommand("clear");
		taskList.executeCommand("add "+A_STRING);
		taskList.executeCommand("add "+B_STRING);
		taskList.executeCommand("add "+C_STRING);
		taskList.executeCommand("add "+D_STRING);
		taskList.executeCommand("add "+E_STRING);
		taskList.executeCommand("add "+F_STRING);
		taskList.executeCommand("add "+G_STRING);
		testOneCommand("simple sort",EXCEPTED_ANSWER_SORT, SORT_COMMAND,taskList);
		assertEquals("Change to todoList", exceptedList, taskList.getTaskList());
		taskList.undo();
		taskList.redo();
		assertEquals("undo test", exceptedList, taskList.getTaskList());
		
		TaskManager taskList2 = new TaskManager();
		taskList.executeCommand("export CaoShengze.txt");
		taskList2.executeCommand("import CaoShengze.txt");
		assertEquals("undo test", true, taskList.getAllTitles().equals(taskList2.getAllTitles()));
		
	}
	private void testOneCommand(String description, String expected, String command, TaskManager taskList) throws NullPointerException, IOException {
		taskList.executeCommand(command);
		assertEquals(description, expected, taskList.getAllTitles()); 
	}
	
	

}
	// End of segment: E:\cs2103final\src\taskList\TaskListTest.java





	/**
	 * origin: E:\cs2103final\src\taskList\TaskManager.java
	 */

public class TaskManager {
	private static final String MESSAGE_EMPTY_FILE = "No related file found";
	private static final String MESSAGE_ADD_OPERATION = "Add new task successfully";
	private static final String MESSAGE_DELETE_OPERATION = "Delete operation successfully";
	private static final String MESSAGE_DELETE_OPERATION_FAILURE = "Index is not valid for delete operation";
	private static final String MESSAGE_CLEAR_OPERATION = "all content has been deleted";
	private static final String MESSAGE_MODIFY_OPERATION = "Modify successfully \n";
	private static final String MESSAGE_MODIFY_OPERATION_FAILURE = "Index is not valid for modify\n";
	private static final String MESSAGE_COMPLETE_OPERATION = "Complete operation successfully";
	private static final String MESSAGE_COMPLETE_OPERATION_FAILURE = "Index is not valid for complete operation";
	public enum SORT_MODE {
		BY_TIME,BY_VENUE,BY_TITLE
	}
	public enum DISPLAY_MODE {
		TODO_TASKLIST, SEARCH_LIST, FINISHED_TASKLIST, ALL_TASKLIST, FILE_PATH
	}
	private String fileName;
	private JsonStringFileOperation fileOperation;
	private ConfigurationFileOperation configurationFileOperation;
	private ArrayList<Task> taskList;
	private ArrayList<Task> completedTaskList;	
	private ArrayList<Task> searchResult;
	
	private DISPLAY_MODE mode = DISPLAY_MODE.TODO_TASKLIST;
	private Parser myParser;
	
	private Undo<ArrayList<Task>> undo;
	private Undo<ArrayList<Task>> undoForCompleted;
	private ArrayList<String> feedBack = new ArrayList<String>();
	private ArrayList<String> fileList = new ArrayList<String>();
	private String name = TaskManager.class.getName(); 
	private int lastOperationIndex = -1;
	private Logger log = Logger.getLogger(name);
	//Only one instance for TaskManager, instead of new a TaskManager, other method get instance by getSharedInstance method
	private static TaskManager sharedInstance; 
	//A date format used to format date so that search and sort is easy to be implemented
	private SimpleDateFormat dateFormat = new SimpleDateFormat(DateParser.FORMAT_DEFAULT);
	
	/*
	 * Construct a TaskManager with a given file name
	 */
	public TaskManager(String inputFileName){
		mode = DISPLAY_MODE.TODO_TASKLIST;
		fileName = inputFileName;
		feedBack.clear();
		try{
			fileOperation = new JsonStringFileOperation(fileName);
			taskList = fileOperation.getUnfinishedTaskListFromFile();
			completedTaskList = fileOperation.getFinishedTaskListFromFile();
			if (completedTaskList == null) completedTaskList = new ArrayList<Task>();
			searchResult = new ArrayList<Task>();
			undo = new Undo<ArrayList<Task>>(taskList);
			undoForCompleted = new Undo<ArrayList<Task>>(completedTaskList);
		}catch(Exception e){
			log.info("There is a command invalid error");
			showMessage("Cannot open the file correctly");
		}
		
		myParser = new Parser();
	}

	/*
	 * Construct a TaskManager based on the configuration file
	 */
	public TaskManager(){
		mode = DISPLAY_MODE.TODO_TASKLIST;
		feedBack.clear();
		try{
			configurationFileOperation = new ConfigurationFileOperation();
			fileName = configurationFileOperation.getLastOpenFilePath();
			fileList = configurationFileOperation.getHistoryFilePath();
			fileOperation = new JsonStringFileOperation(fileName);
		}catch (Exception e){
			showMessage("Something wrong happens when open configuration file");
		}
		try{
			fileOperation = new JsonStringFileOperation(fileName);
			taskList = fileOperation.getUnfinishedTaskListFromFile();
			completedTaskList = fileOperation.getFinishedTaskListFromFile();
			if (completedTaskList == null) completedTaskList = new ArrayList<Task>();
			searchResult = new ArrayList<Task>();
			undo = new Undo<ArrayList<Task>>(taskList);
			undoForCompleted = new Undo<ArrayList<Task>>(completedTaskList);
		}catch(Exception e){
			log.info("There is a command invalid error");
			showMessage("Cannot open the file correctly");
		}
		
		myParser = new Parser();
	}
	
	/*
	 * return the sharedInstance of TaskManager instead of creating more than one instances
	 */
	public static TaskManager getSharedInstance(){
		if (sharedInstance == null) {
			sharedInstance = new TaskManager();
			return sharedInstance;
		}
		return sharedInstance;
	}
	


	/*
	 * parameters: String message
	 * return: Nothing
	 * Description: add message into feedback and provide api for UI to get feedback of last operation
	 */
	private void showMessage(String message) {
		this.feedBack.add(message);
	}

	
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: apis provided for UI to executeCommand
	 */
	
	public void executeCommand(String command) {
		try{
			switch (myParser.getOperation(command)) {
		
			case ADD:
				add(command);
				break;
			case DELETE:
				deleteMultiple(command);
				break;
			case COMPLETE:
				completeMultiple(command);
				break;
			case DISPLAY:
				display(command);
				break;
			case CLEAR:
				clear();
				break;
			case MODIFY:
				modifyMultiple(command);
				break;
			case UNDO:
				undo();
				break;
			case REDO:
				redo();
				break;
			case SORT:
				sort(command);
				break;
			case SEARCH:
				search(command);
				break;
			case EXIT:
				exit();
				break;
			case IMPORT:
				importFile(command);
				break;
			case EXPORT:
				exportFile(command);
				break;
			default:
				assert(false);
				showMessage("No such command");
			}
		}catch (Exception e){
			showMessage(e.getMessage());
		}
	}
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: add task into task list. Can be used in search mode but would not change what displays inside search result
	 */
	private void add(String command) throws Exception{
		//User should not modify the completed task, so the mode would be switched to TODO_TASKLIST automatically
		switchToChangeableMode();
		assert(myParser.isValid(command));
		String content = myParser.getTitle(command);
		try{
			Date date = myParser.getDate(command);
			Date deadLine = myParser.getDeadline(command);
			String venue = myParser.getVenue(command);
			showMessage(MESSAGE_ADD_OPERATION);
			taskList.add(new Task(content,date,deadLine,venue));

			saveFile();
			saveConfiguration();
			undo.add(taskList);
		}catch (Exception e){
			throw e;
		}
	}
	
	/*
	 * parameters: int removeIndex
	 * return: Nothing
	 * Description: delete a single task based on its index. If it is on the search mode, it would delete related task inside taskList
	 */
	private void delete(int removeIndex) throws IOException {
		//User should not modify the completed task, so the mode would be switched to 0 automatically
		switchToChangeableMode();

		if (removeIndex <= 0 || removeIndex > taskList.size()) {
			showMessage(MESSAGE_DELETE_OPERATION_FAILURE);
			return;
		}
		if (mode == DISPLAY_MODE.TODO_TASKLIST) {
			showMessage(MESSAGE_DELETE_OPERATION);
			taskList.remove(removeIndex - 1);
			saveFile(); 
		} else {
			int indexinTaskList = 0;
			for (int i = 0; i < taskList.size(); i++){
				if (taskList.get(i).isEqual(searchResult.get(removeIndex - 1 ))){
					indexinTaskList = i;
					break;
				}
			}
			taskList.remove(indexinTaskList);
			showMessage(MESSAGE_DELETE_OPERATION);
			searchResult.remove(removeIndex - 1);
			saveFile();
		}
	}
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: delete several tasks at the same time
	 */
	private void deleteMultiple(String command) throws Exception{
		ArrayList<Integer> deleteIndex = myParser.getIndex(command);
		Collections.sort(deleteIndex);
		for (int i = deleteIndex.size()-1; i >= 0; i--){
			delete(deleteIndex.get(i));
		}
		undo.add(taskList);
	}	
	
	
	
	/*
	 * parameters: int removeIndex
	 * return: Nothing
	 * Description: complete a single task based on its index. If it is on the search mode, it would complete related task inside taskList
	 * The completed one would be marked as finish and moved to completedTaskList
	 */
	private void complete(int removeIndex) throws IOException {
		//User should not modify the completed task, so the mode would be switched to 0 automatically
		switchToChangeableMode();
		if (mode == DISPLAY_MODE.TODO_TASKLIST){
			
			if (removeIndex < 0 || removeIndex > taskList.size()) {
				showMessage(MESSAGE_COMPLETE_OPERATION_FAILURE);
				return;
			}
			showMessage(MESSAGE_COMPLETE_OPERATION);
			Task finishedOne = taskList.remove(removeIndex - 1);
			//update hasfinished added here		
			Task copyOfFinishedOne = new Task(finishedOne.getContent(),finishedOne.getDate(),finishedOne.getDeadline(),finishedOne.getVenue());
			copyOfFinishedOne.finish();
			completedTaskList.add(copyOfFinishedOne);
			saveFile();
		}else{
			if (removeIndex < 0 || removeIndex > searchResult.size()) {
				showMessage(MESSAGE_DELETE_OPERATION_FAILURE);
				return;
			}
			int indexinTaskList = 0;
			for (int i = 0; i < taskList.size(); i++){
				if (taskList.get(i).isEqual(searchResult.get(removeIndex - 1 ))){
					indexinTaskList = i;
					break;
				}
			}
			Task finishedOne = taskList.get(indexinTaskList);
			Task copyOfFinishedOne = new Task(finishedOne.getContent(),finishedOne.getDate(),finishedOne.getDeadline(),finishedOne.getVenue());
			copyOfFinishedOne.finish();
			completedTaskList.add(copyOfFinishedOne);
			taskList.remove(indexinTaskList);
			showMessage(MESSAGE_DELETE_OPERATION);
			searchResult.remove(removeIndex - 1);
			saveFile();
		}
	}
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: complete several tasks at the same time
	 */
	private void completeMultiple(String command) throws Exception{
		ArrayList<Integer> completeIndex = myParser.getIndex(command);
		Collections.sort(completeIndex);
		for (int i = completeIndex.size()-1; i >= 0; i--){
			complete(completeIndex.get(i));
		}
		undo.add(taskList);
		undoForCompleted.add(completedTaskList);
	}	
	
	
	
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: switch DISPLAY_MODE to relative type based on command
	 */
	private void display(String command) throws NullPointerException, IOException {
		String type = "unfinished";
		try {
			type = myParser.getTitle(command);
		} catch (Exception e) {
			
		}
		if (type.equals("finished")){
			mode = DISPLAY_MODE.FINISHED_TASKLIST;
			if (completedTaskList.size() == 0){
				showMessage(MESSAGE_EMPTY_FILE);
				return;
			}
			showMessage("Display finished Task");
		}else if (type.equals("all")){
			mode = DISPLAY_MODE.ALL_TASKLIST;
			if (completedTaskList.size() + taskList.size() == 0){
				showMessage(MESSAGE_EMPTY_FILE);
				return;
			}
			showMessage("Display all Tasks");
		}else if(type.equals("file")){
			mode = DISPLAY_MODE.FILE_PATH;
			showMessage("Display all files");
		}else{
			mode = DISPLAY_MODE.TODO_TASKLIST;
			if (taskList.size() == 0) {
				showMessage(MESSAGE_EMPTY_FILE);
				return;
			}
			showMessage("Display todo Task");
		}
	}
	
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: modify one task based on its index
	 */
	private void modify(int index, String command) throws Exception{
		//User should not modify the completed task, so the mode would be switched to 0 automatically
		index-= 1;
		switchToChangeableMode();
		if (mode == DISPLAY_MODE.TODO_TASKLIST){
			assert(myParser.isValid(command));
			String content = myParser.getNewTitle(command);
			try{
				lastOperationIndex = index + 1;
				Date newDate = myParser.getDate(command);
				Date deadLine = myParser.getDeadline(command);
				String newVenue = myParser.getVenue(command);
				if ((index < 0)||(index > taskList.size())){
					showMessage(MESSAGE_MODIFY_OPERATION_FAILURE);
					return;
				}
				if (content == null) content = taskList.get(index).getContent();
				if (newVenue == null) newVenue = taskList.get(index).getVenue();
				if (deadLine == null) deadLine = taskList.get(index).getDeadline();
				if (newDate == null) newDate = taskList.get(index).getDate();
				Task newTask = new Task(content,newDate,deadLine,newVenue);
				taskList.remove(index);
				taskList.add(index, newTask);
				showMessage(MESSAGE_MODIFY_OPERATION);
				saveFile();
			}catch (Exception e){
				throw e;
			}
		}else{
			assert(myParser.isValid(command));
			String content = myParser.getNewTitle(command);
			try{
				lastOperationIndex = index + 1;
				Date newDate = myParser.getDate(command);
				Date deadLine = myParser.getDeadline(command);
				String newVenue = myParser.getVenue(command);
				if ((index < 0)||(index > searchResult.size())){
					showMessage(MESSAGE_MODIFY_OPERATION_FAILURE);
					return;
				}
				if (content == null) content = searchResult.get(index).getContent();
				if (newVenue == null) newVenue = searchResult.get(index).getVenue();
				if (deadLine == null) deadLine = searchResult.get(index).getDeadline();
				if (newDate == null) newDate = searchResult.get(index).getDate();
				Task newTask = new Task(content,newDate,deadLine,newVenue);
				int indexinTaskList = 0;
				for (int i = 0; i < taskList.size(); i++){
					if (taskList.get(i).isEqual(searchResult.get(index))){
						indexinTaskList = i;
						break;
					}
				}
				taskList.remove(indexinTaskList);
				taskList.add(index, newTask);
				searchResult.remove(index);
				searchResult.add(newTask);
				showMessage(MESSAGE_MODIFY_OPERATION);
				saveFile();
			}catch (Exception e){
				throw e;
			}
		}
	}	
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: modify several tasks at the same time
	 */
	private void modifyMultiple(String command) throws Exception{
		ArrayList<Integer> modifyIndex = myParser.getIndex(command);
		for (int i = 0; i < modifyIndex.size(); i++){
			modify(modifyIndex.get(i),command);
		}
		undo.add(taskList);
	}	
	
	
	/*
	 * parameters: Nothing
	 * return: Nothing
	 * Description: Redo operation
	 */
	void redo() {
		switchToChangeableMode();
		if (undo.canRedo() && mode == DISPLAY_MODE.TODO_TASKLIST){
			taskList = (ArrayList<Task>) undo.redo();
			if (undoForCompleted.canRedo()) completedTaskList = (ArrayList<Task>) undoForCompleted.redo();
			showMessage("redo operation successfully");
			
		}else{
			showMessage("no redo operation avaiable");
		}			
	}

	/*
	 * parameters: Nothing
	 * return: Nothing
	 * Description: Undo operation
	 */
	void undo() {
		switchToChangeableMode();
		if (undo.canUndo() && mode == DISPLAY_MODE.TODO_TASKLIST){
			taskList = (ArrayList<Task>) undo.undo();
			if (undoForCompleted.canUndo()) {
				completedTaskList = (ArrayList<Task>) undoForCompleted.undo();
			}
			showMessage("undo operation successfully");
		}else{
			showMessage("no undo operation avaiable");
		}
	}	
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: import file based on given command, if file not exist, create a new file
	 */
	private void importFile(String command) throws NullPointerException, IOException{
		boolean isInteger;
		ArrayList<Integer> index = null;
		String newFileName = myParser.getTitle(command);
		try{
			index = myParser.getIndex(command);
			isInteger = true;
		}catch (Exception e){
			isInteger = false;
		}
		if (isInteger){
			if (index.get(0)<= fileList.size()) newFileName = fileList.get(index.get(0)-1);
		}
		if (!fileList.contains(newFileName)){
			showMessage("No such file");
			return;
		}else{
			fileName = newFileName;
			fileOperation = new JsonStringFileOperation(newFileName);
			mode = DISPLAY_MODE.TODO_TASKLIST;
			loadFile();
		}
		saveFile();
		saveConfiguration();
		LayoutSetting.setFilePathLabel();
		showMessage("Import successfully");
	}
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: export file based on given command, if file not exist, create a new file.
	 * If file exist already, just modify the old one
	 */
	private void exportFile(String command) throws IOException{
		String newFileName = myParser.getTitle(command);
		fileName = newFileName;
		fileOperation = new JsonStringFileOperation(newFileName);
		if (!fileList.contains(newFileName)){
			fileList.add(newFileName);
		}
		saveFile();
		saveConfiguration();
		LayoutSetting.setFilePathLabel();
		showMessage("Export successfully");
	}
	
	
	/*
	 * parameters: String string1, String string2
	 * return: boolean
	 * Description: check which string is larger
	 */
	public boolean compareString(String string1, String string2){
		if (string1 == null){
			if (string2 == null) return false;
			return false;
		}else if (string2 == null){
			return true;
		}else{
			return string1.compareTo(string2)<0;
		}
	}
	
	/*
	 * parameters: Date date1, Date date2
	 * return: boolean
	 * Description: check which date is larger
	 */
	public boolean compareDate(Date date1, Date date2){
		if (date1 == null){
			if (date2 == null) return false;
			return false;
		}else if (date2 == null){
			return true;
		}else{
			return date1.compareTo(date2)<0;
		}
	}
	
	/*
	 * parameters: Sort_MODE, type
	 * return: Nothing
	 * Description: sort the taskList based on given SORT_MDOE
	 */
	private void sortTaskList(SORT_MODE type) throws Exception{
		Task[] taskArray = new Task[taskList.size()];
		taskList.toArray(taskArray);
		switch (type){
		case BY_TIME:
			for (int i = 0; i < taskList.size(); i++){
				for (int j = 0; j< i; j++){
				if (compareDate(taskArray[i].getDate(),taskArray[j].getDate())){
						Task tmp = taskArray[i];
						taskArray[i] = taskArray[j];
						taskArray[j] = tmp;
					}
				}
			}
			break;
		case BY_VENUE:
			for (int i = 0; i < taskList.size(); i++){
				for (int j = 0; j< i; j++){
				if (compareString(taskArray[i].getVenue(),taskArray[j].getVenue())){
						Task tmp = taskArray[i];
						taskArray[i] = taskArray[j];
						taskArray[j] = tmp;
					}
				}
			}
			break;
		case BY_TITLE:
			for (int i = 0; i < taskList.size(); i++){
				for (int j = 0; j< i; j++){
				if (compareString(taskArray[i].getContent(),taskArray[j].getContent())){
						Task tmp = taskArray[i];
						taskArray[i] = taskArray[j];
						taskArray[j] = tmp;
					}
				}
			}
			break;
		default:
			throw new Exception("Invalid Sort Operation");
		}
		taskList = new ArrayList<Task>();
		for (int i = 0; i< taskArray.length ; i++){
			taskList.add(taskArray[i]);
		}
		
		
	}
	
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: sort taskList based on receive command
	 */
	private void sort(String command) throws Exception {
		String content;
		try{
			content = myParser.getTitle(command);
		}catch(Exception e){
			content = "time";
		}
		
		content.toLowerCase();
		if (content.equals("time")){
			try {
				sortTaskList(SORT_MODE.BY_TIME);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}else if (content.equals("venue")){
			try {
				sortTaskList(SORT_MODE.BY_VENUE);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}else if (content.equals("title")){
			try {
				sortTaskList(SORT_MODE.BY_TITLE);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}else{
			throw new Exception("No such command");
		}
		
		undo.add(taskList);
		showMessage("sort finished");
		saveFile();
	}	
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: search taskList based on receive command
	 */
	private void search(String command) throws NullPointerException, IOException {
		mode = DISPLAY_MODE.SEARCH_LIST;
		searchResult.clear();
		String keyWord = myParser.getTitle(command);
		if (keyWord.equals("today")){
			dateFormat = new SimpleDateFormat (DateParser.FORMAT_DEFAULT);
			keyWord = dateFormat.format(myParser.getDate("add -d today"));
		}
		for (int i = 0; i < taskList.size(); i++){
			if (taskList.get(i).containKeyWord(keyWord)){
				searchResult.add(taskList.get(i));
			}
		}
		showMessage("search result is right here");
	}
	
	/*
	 * parameters: String command
	 * return: Nothing
	 * Description: delete all tasks inside taskList
	 */
	private void clear() throws IOException {
		showMessage(MESSAGE_CLEAR_OPERATION);
		taskList.clear();
		saveFile();
	}
	
	
	/*
	 * parameters: Nothing
	 * return: Nothing
	 * Description: save file and exit safely
	 */
	private void exit() throws IOException {
		saveFile();
		saveConfiguration();
		UserInterface.exit();
		System.exit(0);
	}
	
	/*
	 * parameters: Nothing
	 * return: Nothing
	 * Description: save file
	 */
	private void saveFile() throws IOException{
			fileOperation.saveToFile(taskList,completedTaskList);
	}
	
	/*
	 * parameters: Nothing
	 * return: Nothing
	 * Description: load file
	 */
	private void loadFile() throws IOException{
		taskList = fileOperation.getUnfinishedTaskListFromFile();
		completedTaskList = fileOperation.getFinishedTaskListFromFile();
		fileList = configurationFileOperation.getHistoryFilePath();
	}
	
	/*
	 * parameters: Nothing
	 * return: Nothing
	 * Description: save configuration
	 */
	private void saveConfiguration() throws IOException{
		configurationFileOperation.saveConfiguration(fileName, fileList);;
	}
	
	/*
	 * parameters: Nothing
	 * return: Nothing
	 * Description: There are 5 DISPLAY_MODE, only two of them can accept CRUD operation, if 
	 * mode is at some one which cannot accept CRUD, change it to TODO_TASKLIST mode.
	 */
	private void switchToChangeableMode(){
		if (mode != DISPLAY_MODE.SEARCH_LIST){
			mode = DISPLAY_MODE.TODO_TASKLIST;
		}
	}
	
	/*
	 * parameters: Nothing
	 * return: ArrayList<String>
	 * Description: return a copy of task content
	 */
	public ArrayList<String> getFileContent(){
		ArrayList<String> content = new ArrayList<String>(); 
		for (Task task: taskList){
			content.add(task.getContent());
		}
		return content;
	}

	/*
	 * parameters: Nothing
	 * return: ArrayList<Task>
	 * Description: return a copy of taskList based on current DISPLAY_MODE
	 */
	@SuppressWarnings("unchecked")
	public ArrayList<Task> getTasks(){
		switch (mode){
		case TODO_TASKLIST:
			ArrayList<Task> answers = new ArrayList<Task>();
			for (int i = 0; i < taskList.size(); i++){
				if (!taskList.get(i).hasFinished())
					answers.add(taskList.get(i));
			}
			return answers;
		case SEARCH_LIST:
			return (ArrayList<Task>) searchResult.clone();
		case FINISHED_TASKLIST:
			return (ArrayList<Task>) completedTaskList.clone();
		case ALL_TASKLIST:
			ArrayList<Task> bothTaskList = (ArrayList<Task>) taskList.clone();
			bothTaskList.addAll((ArrayList<Task>)completedTaskList.clone());
			return bothTaskList;
		default:
			ArrayList<Task> answers2 = new ArrayList<Task>();
			for (int i = 0; i < taskList.size(); i++){
				if (!taskList.get(i).hasFinished())
					answers2.add(taskList.get(i));
			}
			return answers2;
		}
	}
		
	/*
	 * parameters: Nothing
	 * return: ArrayList<String>
	 * Description: return a copy of all feedbacks
	 */
	@SuppressWarnings("unchecked")
	public ArrayList<String> getFeedBacks(){
		return (ArrayList<String>) feedBack.clone();
	}
	
	/*
	 * parameters: Nothing
	 * return: String
	 * Description: return last feedBack
	 */
	public String getLastFeedBack(){
		if (feedBack.size() == 0) feedBack.add("No feedback");
		return feedBack.get(feedBack.size()-1);
	}
	
	/*
	 * parameters: Nothing
	 * return: String
	 * Description: return all titles in one String, used for unit tests
	 */
	public String getAllTitles(){
		String answer = new String("");
		if (mode == DISPLAY_MODE.TODO_TASKLIST){
			for (int i = 0; i < taskList.size(); i++){
				answer = answer + (i+1) + ". "+ taskList.get(i).getContent()+"\n";
			}
			return answer;
		}else{
			for (int i = 0; i < searchResult.size(); i++){
				answer = answer + (i+1) + ". "+ searchResult.get(i).getContent()+"\n";
			}
			if (answer.equals("")){
				return "No results found\n";
			}
			return answer;		
		}
	}
	
	/*
	 * parameters: Nothing
	 * return: ArrayList<String>
	 * Description: return all titles in one arraylist of string, used for unit tests
	 */
	public ArrayList<String> getTaskList(){
		ArrayList<String> answers = new ArrayList<String>();
		for (int i = 0; i < taskList.size(); i++){
			answers.add(taskList.get(i).getContent());
		}
		return answers;
	}
	

	/*
	 * parameters: TaskManager taskList2
	 * return: boolean
	 * Description: check whether two TaskManager is the same. Return a boolean value.
	 */
	public boolean isEqual(TaskManager taskList2){
		if (this.taskList.size() != taskList2.taskList.size()) return false;
		@SuppressWarnings("unchecked")
		ArrayList<Task> taskListCopy1 = (ArrayList<Task>) this.taskList.clone();
		@SuppressWarnings("unchecked")
		ArrayList<Task> taskListCopy2 = (ArrayList<Task>) taskList2.taskList.clone();
		Collections.sort(taskListCopy1);
		Collections.sort(taskListCopy2);
		for (int i = 0; i< taskListCopy1.size(); i++){
			if (!taskListCopy1.get(i).isEqual(taskListCopy2.get(i))){
				return false;
			}
		}
		return true;
	}
	
	/*
	 * parameters: Nothing
	 * return: int
	 * Description: return last index. For UI to get to know more information
	 */
	public int getLastOperationIndex(){
		return lastOperationIndex;
	}
	
	/*
	 * parameters: String command
	 * return: String
	 * Description: accept a String as a parameter, return the suggested filled up string
	 */
	public String getAutoFill(String command){
		return myParser.autoFill(command);
	}
	
	/*
	 * parameters: String command
	 * return: String
	 * Description: accept a String as a parameter, return the suggested tip
	 */
	public String getCommandTip(String command){
		return myParser.provideTips(command);
	}
	
	/*
	 * parameters: Nothing
	 * return: DISPLAY_MODE
	 * Description: used for UI to get to know what is shown now
	 */
	public DISPLAY_MODE getCurrentMode(){
		
		return mode;
	}
	
	/*
	 * parameters: Nothing
	 * return: String
	 * Description: used for UI to get to know what is current path
	 */
	public String getCurrentPath(){
		return  fileName;
	}

	/*
	 * parameters: Nothing
	 * return: ArrayList<String>
	 * Description: used for UI to get to know all file paths.
	 */
	@SuppressWarnings("unchecked")
	public ArrayList<String> getAllFilePath(){
		return (ArrayList<String>) this.fileList.clone();
	}
	

}

	// End of segment: E:\cs2103final\src\taskList\TaskManager.java





	/**
	 * origin: E:\cs2103final\src\taskList\TaskTest.java
	 */

public class TaskTest {	
	Parser myParser = new Parser();


	@Test
	public void testContainKeyWord() throws NullPointerException, IOException {
		Date date1 = myParser.getDate("add -d 2015-04-12 13:00");
		Task task1 = new Task("task1",  date1, date1, "lt27");
		assertEquals("contain function", false, task1.containKeyWord("2016")); 
		assertEquals("contain function", true, task1.containKeyWord("2015"));
	}
	
	@Test
	public void testOutofDate() throws NullPointerException, IOException {
		Date date1 = myParser.getDate("add -d 2014-04-12 13:00");
		Date date2 = myParser.getDate("add -d 2015-04-13 13:00");
		Task task1 = new Task("task1",  date1, date1, "lt27");
		Task task2 = new Task("task2",  date2, date2, "lt27");
		assertEquals("contain function", true, task1.isOutOfDate()); 
		assertEquals("contain function", false, task2.isOutOfDate());
	}


}
	// End of segment: E:\cs2103final\src\taskList\TaskTest.java





	/**
	 * origin: E:\cs2103final\src\taskList\Undo.java
	 */

public class Undo<T> {  
      
	private ArrayList<T> stack = new ArrayList<T>();
	private int pointer;
	
	
	@SuppressWarnings("unchecked")
	public Undo(T initElement){
		ArrayList<Task> newStatusClone = (ArrayList<Task>) initElement;
		ArrayList<Task> newStatusClone2 = new ArrayList<Task>();
		for (int i=0; i< newStatusClone.size(); i++){
			newStatusClone2.add(newStatusClone.get(i).getCopy());
		}
		stack.add(((T) newStatusClone2));
		pointer = 0;
	}
	
	@SuppressWarnings("unchecked")
	public T undo(){
		if (stack.size() == 1){
			ArrayList<Task> returnCopy = new ArrayList<Task>();
			returnCopy = (ArrayList<Task>) stack.get(pointer);
			ArrayList<Task> returnCopy2 = (ArrayList<Task>) returnCopy.clone();
			return (T) returnCopy2;
		}else{
			pointer--;
			ArrayList<Task> returnCopy = new ArrayList<Task>();
			returnCopy = (ArrayList<Task>) stack.get(pointer);
			ArrayList<Task> returnCopy2 = (ArrayList<Task>) returnCopy.clone();
			return (T) returnCopy2;
		}
	}
	
	public void reset(){
		for (int i=1; i< stack.size(); i++){
			stack.remove(i);
		}
		pointer = 0;
	}
	
	@SuppressWarnings("unchecked")
	public T redo(){
		if (pointer < stack.size()-1){
			pointer++;
		}
		ArrayList<Task> returnCopy = new ArrayList<Task>();
		returnCopy = (ArrayList<Task>) stack.get(pointer);
		ArrayList<Task> returnCopy2 = (ArrayList<Task>) returnCopy.clone();
		return (T) returnCopy2;
	}
	
	@SuppressWarnings("unchecked")
	public void add(T newStatus){
		for (int i = pointer+1; i < stack.size();i++){
			stack.remove(i);
		}
		ArrayList<Task> newStatusClone = (ArrayList<Task>) newStatus;
		ArrayList<Task> newStatusClone2 = new ArrayList<Task>();
		for (int i=0; i< newStatusClone.size(); i++){
			newStatusClone2.add(newStatusClone.get(i).getCopy());
		}
		stack.add((T)newStatusClone2);
		pointer++;
	}
	
	public boolean canRedo(){
		return pointer<stack.size()-1;
	}
	
	public boolean canUndo(){
		return pointer>0;
	}

	
	
	
}  
	// End of segment: E:\cs2103final\src\taskList\Undo.java





